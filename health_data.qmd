---
title: "Health Data"
author: "Belen Zapata-Diomedi, Steve Pemberton"
email: "mbzd2@cam.ac.uk, mb2592@cam.ac.uk, steve.pemberton@rmit.edu.au"
date: today
format: 
  html:
    code-fold: true
    embed-resources: true
    df-print: paged
    toc: true
    number-sections: true
execute: 
  echo: false
  message: false
  warning: false
editor_options:
  mode: visual
  markdown:
    wrap: 72
---

# Introduction

This document explains and produces estimates for the inputs for the
health model for MIAMA. The model initially has four stages
where individuals are in a healthy state, might become diseased of one
or more diseases, and die from any causes (all cause mortality). All
cause mortality is also dependent on diseases status, meaning that if a
person has a given disease (i.e. diabetes, dementia, parkinson, cancers,
copd) their probability of dying is higher. Diabetes is a risk factor
for cardiovascular diseases (ischemic heart disease and stroke) and
included in the model. The model does not include trend of diseases but
assumes that current rates by age, sex and area will be observed in the
future.

The purpose of this document is to produce health inputs for all-cause
mortality and diseases' incidence and prevalence. Prevalence is used to
assign initial state as diseased.

```{r setup, include=FALSE}

rm(list = ls())

library(tidyverse)  # Includes dplyr, tidyr, readr, ggplot2, purrr, etc.
library(readxl)     # Read/write Excel files
library(knitr)      # Report generation
library(gt)         # Pretty tables
library(here)       # File path management
library(plotly)     # Interactive plots
library(htmlwidgets)# Save interactive plots
library(esquisse)   # Interactive ggplot2 figures [not used?]
library(mgcv)       # Smoothing
# Set root directory one level up from current directory
knitr::opts_knit$set(root.dir = dirname(getwd()))

# Functions
source("functions/interpolation.R") 
source("functions/gbd_process.R")


# Avoid scientific notation
options("scipen"=100, "digits"=4)

```

# All-Cause Mortality

## Data Sources

1.  Mortality by LSOA by age and sex for year 2018 from ONS.

    <https://www.ons.gov.uk/peoplepopulationandcommunity/birthsdeathsandmarriages/deaths/adhocs/1028deathregistrationsbysexfiveyearagegroupandlowerlayersuperoutputareaslsoa2011censusboundariesenglandandwales2001to2021>

2.  Population Data by LSOA by age and sex for 2018 mid year, and 2023 mid year (downloaded 12-Nov-25), from ONS.

    <https://www.ons.gov.uk/peoplepopulationandcommunity/populationandmigration/populationestimates/datasets/lowersuperoutputareamidyearpopulationestimates>

3.  Geographical Hierarchy (as of 2011) and table of correspondences to regions

    <https://geoportal.statistics.gov.uk/datasets/ons::lsoa-2011-to-travel-to-work-area-december-2011-exact-fit-lookup-in-the-uk/about>
    
    <https://geoportal.statistics.gov.uk/datasets/ons::lsoa-2011-to-lsoa-2021-to-local-authority-district-2022-best-fit-lookup-for-ew-v2/about>
    
4.  Life tables England (2017-2019)

    <https://www.ons.gov.uk/peoplepopulationandcommunity/birthsdeathsandmarriages/lifeexpectancies/datasets/nationallifetablesenglandreferencetables/current>

5.  Level of multiple deprivation

    <https://opendatacommunities.org/resource?uri=http%3A%2F%2Fopendatacommunities.org%2Fdata%2Fsocietal-wellbeing%2Fimd2019%2Findices>

6.  European standard population

    <https://publichealthscotland.scot/services/national-data-catalogue/national-datasets/search-the-datasets/european-standard-population/>
    
7.  Age-standardised mortality rates from ONS for 2018, downloaded 8-Nov-25

    <https://www.nomisweb.co.uk/datasets/mortsa>
    
    Details selected for download: 
    - Geography: 'local authorities: district / unitary (as of April 2023)
    - Date: 2018
    - Age: All
    - Rates: Age-standardised mortality rate
    - Sex: All
    - Underlying Cause > Full ICD_10 Classification: Total


```{r data-prep}

# Functions for cleaning population
clean_pop <- function(df) {
  df %>%
    filter(LSOA != "", !str_starts(`Area Codes`, "W")) %>%   # keep England only
    rename(lsoa_name = LSOA, lsoa_code = `Area Codes`) %>%
    select(-c(2, 4))  # drop duplicate/area cols
}

agg5 <- function(df) {
  df %>%
    mutate(
      `00 to 04` = rowSums(select(., `0`:`4`), na.rm = TRUE),
      `05 to 09` = rowSums(select(., `5`:`9`), na.rm = TRUE),
      `10 to 14` = rowSums(select(., `10`:`14`), na.rm = TRUE),
      `15 to 19` = rowSums(select(., `15`:`19`), na.rm = TRUE),
      `20 to 24` = rowSums(select(., `20`:`24`), na.rm = TRUE),
      `25 to 29` = rowSums(select(., `25`:`29`), na.rm = TRUE),
      `30 to 34` = rowSums(select(., `30`:`34`), na.rm = TRUE),
      `35 to 39` = rowSums(select(., `35`:`39`), na.rm = TRUE),
      `40 to 44` = rowSums(select(., `40`:`44`), na.rm = TRUE),
      `45 to 49` = rowSums(select(., `45`:`49`), na.rm = TRUE),
      `50 to 54` = rowSums(select(., `50`:`54`), na.rm = TRUE),
      `55 to 59` = rowSums(select(., `55`:`59`), na.rm = TRUE),
      `60 to 64` = rowSums(select(., `60`:`64`), na.rm = TRUE),
      `65 to 69` = rowSums(select(., `65`:`69`), na.rm = TRUE),
      `70 to 74` = rowSums(select(., `70`:`74`), na.rm = TRUE),
      `75 to 79` = rowSums(select(., `75`:`79`), na.rm = TRUE),
      `80 to 84` = rowSums(select(., `80`:`84`), na.rm = TRUE),
      `over 85`  = rowSums(select(., `85`:`89`, `90+`), na.rm = TRUE)
    ) %>%
    select(lsoa_code, lsoa_name,
           `00 to 04`,`05 to 09`,`10 to 14`,`15 to 19`,`20 to 24`,`25 to 29`,
           `30 to 34`,`35 to 39`,`40 to 44`,`45 to 49`,`50 to 54`,`55 to 59`,
           `60 to 64`,`65 to 69`,`70 to 74`,`75 to 79`,`80 to 84`,`over 85`) %>%
    pivot_longer(-c(lsoa_name, lsoa_code), names_to = "age", values_to = "population")
}

syoa_from_clean <- function(df, gender_label) {
  age_cols <- names(df)[names(df) %in% as.character(0:89)]
  keep <- c("lsoa_code", "lsoa_name", age_cols, intersect("90+", names(df)))
  df %>%
    select(all_of(keep)) %>%
    pivot_longer(cols = -c(lsoa_name, lsoa_code),
                 names_to = "age_chr", values_to = "population") %>%
    mutate(age = as.integer(gsub("\\+", "", age_chr)),
           age = pmin(age, 90L),
           gender = gender_label) %>%
    select(lsoa_code, lsoa_name, gender, age, population)
}

# Mortality by LSOA by age and sex (Year: 2018) 
# Source: ONS Death registrations by sex, five-year age group and LSOA (2001–2021)
# https://www.ons.gov.uk/peoplepopulationandcommunity/birthsdeathsandmarriages/deaths/adhocs/1028deathregistrationsbysexfiveyearagegroupandlowerlayersuperoutputareaslsoa2011censusboundariesenglandandwales2001to2021

tmpdir <- tempdir()
deathsfile <- unzip(here("health_data/original/ons",  "DeathsbyLSOAmidyear11to21.zip"),
                    exdir = tmpdir)[1]
deaths_males <- read_xlsx(deathsfile, sheet = "2", skip = 2) %>%
  filter(`Mid-year` == 2018)
deaths_females <- read_xlsx(deathsfile, sheet = "3", skip = 2) %>%
  filter(`Mid-year` == 2018)

deaths <- merge(deaths_males, deaths_females, by = c("LSOA code")) %>%
  pivot_longer(cols = c(starts_with("Males"), starts_with("Females")),
               names_to = c("gender", "age"),
               names_pattern = "(Males|Females) (.+)",
               values_to = "deaths")

deaths_england <- deaths %>%
  filter(!str_starts(`LSOA code`, "W")) %>%               # drop Wales
  select(lsoa_code = `LSOA code`,
         lsoa_name = `LSOA name.x`,
         gender, age, deaths) %>%
  mutate(age = case_when(age %in% c("under 1", "01 to 04") ~ "00 to 04",
                         TRUE ~ age)) %>%
  group_by(lsoa_code, lsoa_name, age, gender) %>%
  summarise(deaths = sum(deaths), .groups = "drop")

rm(deaths, deaths_males, deaths_females)
 
# Population (2018): 5-YR BANDS + SINGLE-YEAR
# Source: ONS LSOA mid-year population estimates
# https://www.ons.gov.uk/peoplepopulationandcommunity/populationandmigration/populationestimates/datasets/lowersuperoutputareamidyearpopulationestimates

pop_males_raw <- read_xlsx(
  here("health_data/original/ons", "SAPE21DT1a-mid-2018-on-2019-LA-lsoa-syoa-estimates-formatted.xlsx"),
  sheet = "Mid-2018 Males", skip = 3
)

pop_females_raw <- read_xlsx(
  here("health_data/original/ons", "SAPE21DT1a-mid-2018-on-2019-LA-lsoa-syoa-estimates-formatted.xlsx"),
  sheet = "Mid-2018 Females", skip = 3
)

pop_males_clean   <- clean_pop(pop_males_raw)
pop_females_clean <- clean_pop(pop_females_raw)

# 5-year age groups
pop_males_5   <- agg5(pop_males_clean)   %>% mutate(gender = "Males")
pop_females_5 <- agg5(pop_females_clean) %>% mutate(gender = "Females")
population_england <- bind_rows(pop_males_5, pop_females_5)

# Single-year-of-age (0..90, with 90+ collapsed to 90)
pop_males_syoa   <- syoa_from_clean(pop_males_clean,   "Males")
pop_females_syoa <- syoa_from_clean(pop_females_clean, "Females")
population_england_syoa <- bind_rows(pop_males_syoa, pop_females_syoa)

rm(pop_males_raw, pop_females_raw,
   pop_males_clean, pop_females_clean,
   pop_males_5, pop_females_5, pop_males_syoa, pop_females_syoa)

# Population (2023): single year
# Source: ONS LSOA mid-year population estimates
# https://www.ons.gov.uk/peoplepopulationandcommunity/populationandmigration/populationestimates/datasets/lowersuperoutputareamidyearpopulationestimates
# note that age '90' in the table is actually 90+ 

pop_england_syoa_2023 <- read_xlsx(
  here("health_data/original/ons", "sapelsoasyoa20222024.xlsx"),
  sheet = "Mid-2023 LSOA 2021", skip = 3
) %>%
  rename(lsoa_name = `LSOA 2021 Name`, lsoa_code = `LSOA 2021 Code`) %>%
  filter(lsoa_code != "", !str_starts(lsoa_code, "W")) %>%   # keep England only
  select(-c(1, 2, 5)) %>% # drop LAD/total cols
  pivot_longer(
    cols = starts_with(c("F", "M")),  # all F* and M* columns
    names_to = c("sex", "age"),       # create two new columns
    names_pattern = "([FM])(\\d+)",   # extract letter and digits
    values_to = "population"          # name of the values column
  ) %>%
  mutate(
    sex = recode(sex, F = "Females", M = "Males"),
    age = as.integer(age)
  )


# Geographical Hierarchy (as of 2011)
# Source: https://geoportal.statistics.gov.uk/datasets/ons::lsoa-2011-to-travel-to-work-area-december-2011-exact-fit-lookup-in-the-uk/about

msoa <- read.csv(here('health_data/original/ons/lsoa_2011.csv')) %>%
  select(2:7) %>%
  distinct()
# Columns: lsoa code, msoa code, lad code, lsoa name, msoa nmae, lad name


# Source: https://geoportal.statistics.gov.uk/datasets/ons::lsoa-2011-to-lsoa-2021-to-local-authority-district-2022-best-fit-lookup-for-ew-v2/about
# OA21 → LSOA21 → MSOA21 → LAD22 (England & Wales; filter to England)
oa21_lookup <- read_csv(
  here("health_data/original/ons/LSOA_(2012)_to_LSOA_(2021)_to_Local_Authority_District_(2022)_Best_Fit_Lookup_for_EW_(V2).csv"),
  show_col_types = FALSE
) %>%
  filter(str_starts(LAD22CD, "E"))  # keep England LADs only

# Life Tables for England (2017-2019)
# Source: https://www.ons.gov.uk/peoplepopulationandcommunity/birthsdeathsandmarriages/lifeexpectancies/datasets/nationallifetablesenglandreferencetables/current
lifetable_england  <- read.csv(here('health_data/original/ons/life_tables_20172019.csv'),skip = 5)

# Indices of Deprivation by LSOA (2019)
# Source: https://opendatacommunities.org/resource?uri=http%3A%2F%2Fopendatacommunities.org%2Fdata%2Fsocietal-wellbeing%2Fimd2019%2Findices
deprivation <- read_csv(here('health_data/original/ons/imd2019lsoa.csv')) 

# European Standard Population 2013
# Source: https://publichealthscotland.scot/services/national-data-catalogue/national-datasets/search-the-datasets/european-standard-population/
european_pop <- read.csv(here('health_data/original/ons/european_standard_population_by_sex.csv'))

# Age-standardised mortality rates for 2018, downloaded 8-Nov-25 (ONS/NOMIS)
# Source: https://www.nomisweb.co.uk/datasets/mortsa 
nomis_lad <- read_xlsx(here("health_data/original/ons/nomis_2025_11_07_221958.xlsx"), 
                       skip = 337) %>%
  slice(c(3:320, 334:651)) %>%  # rows for males/females
  dplyr::select(lad_name = measure, asmn = `Age-standardised mortality rate`) %>%
  mutate(gender = ifelse(row_number() < 319, "Males", "Females"),
         stdrate_ons = as.numeric(asmn) / 100) %>%
  dplyr::select(gender, lad_name, stdrate_ons)

```

## Mortality rates by year of age and sex for England

The mortality rate `mx` is defined as "the number of deaths at age x
last birthday in the three year period (2017-2019) divided by the
average population at that age over the same period. This is the
starting data to further expand by LSOAs based on the ratio of the
age-standardised mortality rates by sex for each LSOA relative to
England as a whole. ASDR are not publicly available at LSOA, therefore,
we calculated them.

```{r mortality-syoa}

lifetable_england <- lifetable_england[, -c(3,7,8,10)] 

mf <- rep(c("male","female"),each=4)
names1 <- rep(c("rate","denom","deaths","le"), 2)
names(lifetable_england) <- c("age",paste(mf, names1, sep = "_"))

lifetable_england <- lifetable_england %>% 
  mutate(male_personyears   = round(male_denom   - male_deaths),
         female_personyears = round(female_denom - female_deaths)) %>% 
  select(age, male_denom, male_rate, male_personyears, male_le,
         female_denom, female_rate, female_personyears, female_le)

england_lifetable <- lifetable_england %>%
  pivot_longer(-age, names_to = c("sex","measure"), names_sep = "_") %>%
  pivot_wider(names_from = "measure", values_from = value) %>%
  mutate(
    rate1000 = rate * 1000,
    sex = factor(sex, labels = stringr::str_to_title(sort(unique(.data$sex)))),
    sex = relevel(sex, "Male")
  ) %>%
  mutate(sex = if_else(as.character(sex) == "Male", "Males", "Females")) %>%
  select(age, sex, rate1000)

```

## Population weights for age groups and sex for England

To derive age-standardized rates for each LSOA by sex and then derive
ratios of mortality rate for LSOAs by sex, we need population weights
for our reference population of England. We constructed these weights
using population data for England. We also, further down the document,
construct ratios using European standard population for validation
purposes of data by LAD (for which there are publicly available ASDR by
LAD and sex).

```{r pop-weights}
# Population weight for each age group within all lsoas in England. England is our reference population, since the RRs will then be multiplied by death rates by age and sex for the whole of England. 

# Calculate age-specific population and join with gender totals
population_england_total <- population_england %>%
  group_by(age, gender) %>%
  summarise(age_population = sum(population), .groups = "drop")

population_gender_England <- population_england %>%
  group_by(gender) %>%
  summarise(gender_population = sum(population), .groups = "drop")

population_weights_England <- population_england_total %>%
  left_join(population_gender_England, by = "gender") %>%
  mutate(weight = age_population / gender_population) %>%
  select(gender, age, weight)

# European Standard Population (2013) -> weights table 
european_pop_2 <- european_pop %>%
  mutate(Sex = ifelse(Sex == "Male", "Males", "Females")) %>%
  rename(
    age       = AgeGroup,
    gender    = Sex,
    population = EuropeanStandardPopulation
  ) %>%
  mutate(
    age = case_when(
      age %in% c("90plus years","85-89 years") ~ "over 85",
      TRUE ~ str_replace(age, "(\\d+)-(\\d+)", "\\1 to \\2")
    ),
    age = str_replace_all(age, "\\b(\\d)\\b", "0\\1"),
    age = str_replace(age, " years", ""),
    age = if_else(age == "00 to 04", "01 to 04", age)
  ) %>%
  group_by(age, gender) %>%
  summarise(population = sum(population), .groups = "drop")

population_weights_europe <- european_pop_2 %>%
  group_by(gender, age) %>%
  summarise(age_population = sum(population), .groups = "drop") %>%
  mutate(weight = age_population / 100000) %>%
  select(age, gender, weight)

```

## Relative Risk

A relative mortality rate is produced for each area (lsoa), defined as
the age-standardised mortality rate by sex for each lsoa relative to the
average mortality in England by sex.

The age-standardized mortality rate (ASMR) (direct standardization) by
sex and lsoa is calculated by first finding the age-specific (mortality)
rates for each age group (5 years) by dividing the number of deaths by
the respective population by sex, then multiplying the result by 1000,
then the sum of the product of each of the age-specific rates by the
proportion of the population belonging to the particular age group
(standard population weight) by area and sex. For England as a whole,
the average mortality is defined as a weighted average of the
area-specific rates, weighted by the population of each area.

For future reference (
[https://pmc.ncbi.nlm.nih.gov/articles/PMC9575652](https://pmc.ncbi.nlm.nih.gov/articles/PMC9575652/))
we might want to improve the calculation of ASDR.

We calculated ASDRs for lsoas, msoas and lads. While we want the
relative risks for each lsoa compared to England as a whole, some lsoa
have small deaths numbers, in those cases we replaced by msoas or lads
if msoas still had small numbers. We applied a rule that if less than 10
deaths in an age group in an lsoa, then a msoa ASDRs should be used, and
if more than 10 deaths but less than 20 in an MSOA, then use the LAD
ASDRs.

### LSOAs. MSOAs and LADs ASDRs by sex

```{r relative-risks}

# note function uses eur rates; can replace with eng rates when calling, to compare
compute_asdr <- function(df_deaths, df_pop, by_keys,
                         weights = population_weights_europe) { 
  deaths_clean <- df_deaths %>%
    select(all_of(by_keys), deaths) %>%
    group_by(across(all_of(by_keys))) %>%
    summarise(deaths = sum(deaths, na.rm = TRUE), .groups = "drop")
  
  pop_clean <- df_pop %>%
    select(all_of(by_keys), population) %>%
    group_by(across(all_of(by_keys))) %>%
    summarise(population = sum(population, na.rm = TRUE), .groups = "drop")
  
  deaths_clean %>%
    left_join(pop_clean, by = by_keys) %>%
    mutate(age_specific_rate = case_when(
      population > 0 ~ deaths / population * 1000,
      population == 0 & deaths == 0 ~ 0,
      population == 0 & deaths > 0 ~ NA_real_
    )) %>%
    left_join(weights, by = c("age","gender")) %>%
    group_by(across(all_of(setdiff(by_keys, "age")))) %>%
    summarise(
      stdrate    = sum(replace_na(age_specific_rate, 0) * weight, na.rm = TRUE),
      pop_geo    = sum(population, na.rm = TRUE),
      deaths_geo = sum(deaths, na.rm = TRUE),
      .groups    = "drop"
    )
}

# LSOA
deaths_lsoa_eng <- deaths_england %>%
  left_join(population_england, by = c("lsoa_code","lsoa_name","gender","age")) %>%
  select(lsoa_code, lsoa_name, gender, age, deaths, population)

deaths_lsoa_eng_asdr <- compute_asdr(
  df_deaths = deaths_lsoa_eng,
  df_pop    = deaths_lsoa_eng %>% select(lsoa_code, lsoa_name, gender, age, population),
  by_keys   = c("lsoa_code","lsoa_name","gender","age")
) %>%
  rename(population_lsoa = pop_geo, deaths_lsoa = deaths_geo)

# MSOA (aggregate LSOA up)
deaths_msoa <- deaths_england %>%
  left_join(msoa, by = c("lsoa_code" = "LSOA11CD")) %>%
  transmute(msoa_code = MSOA11CD, msoa_name = MSOA11NM, gender, age, deaths)

population_msoa <- population_england %>%
  left_join(msoa, by = c("lsoa_code" = "LSOA11CD")) %>%
  transmute(msoa_code = MSOA11CD, msoa_name = MSOA11NM, gender, age, population)

deaths_msoa_eng_asdr <- compute_asdr(
  df_deaths = deaths_msoa %>% group_by(msoa_code, msoa_name, gender, age) %>%
    summarise(deaths = sum(deaths, na.rm = TRUE), .groups = "drop"),
  df_pop    = population_msoa %>% group_by(msoa_code, msoa_name, gender, age) %>%
    summarise(population = sum(population, na.rm = TRUE), .groups = "drop"),
  by_keys   = c("msoa_code","msoa_name","gender","age")
) %>%
  rename(deaths_msoa = deaths_geo)

# LAD (aggregate LSOA up)
deaths_lad <- deaths_england %>%
  left_join(msoa, by = c("lsoa_code" = "LSOA11CD")) %>%
  transmute(lad_code = LAD11CD, lad_name = LAD11NM, gender, age, deaths)

population_lad <- population_england %>%
  left_join(msoa, by = c("lsoa_code" = "LSOA11CD")) %>%
  transmute(lad_code = LAD11CD, lad_name = LAD11NM, gender, age, population)

deaths_lad_eng_asdr <- compute_asdr(
  df_deaths = deaths_lad %>% group_by(lad_code, lad_name, gender, age) %>%
    summarise(deaths = sum(deaths, na.rm = TRUE), .groups = "drop"),
  df_pop    = population_lad %>% group_by(lad_code, lad_name, gender, age) %>%
    summarise(population = sum(population, na.rm = TRUE), .groups = "drop"),
  by_keys   = c("lad_code","lad_name","gender","age")
) %>% rename(deaths_lad = deaths_geo)

```


## Deprivation data

```{r deprivation}

# Tidy IMD at LSOA11 level
deprivation_lsoa11 <- deprivation %>%
  filter(`Indices of Deprivation` == "a. Index of Multiple Deprivation (IMD)",
         Measurement == "Decile") %>%
  mutate(deprivation = "IMD") %>%
  rename(lsoa11_code = FeatureCode) %>%
  transmute(
    lsoa11_code,
    imd_decile = as.integer(Value),  # ensure numeric 1..10
    deprivation
  )

# Map IMD (LSOA11) → LSOA21
#    - For splits: each new LSOA21 inherits the source LSOA11 decile.
#    - For merges (several LSOA11 into one LSOA21): take the most deprived (min decile).
deprivation_lsoa21 <- oa21_lookup %>%
  left_join(deprivation_lsoa11, by = c("LSOA11CD" = "lsoa11_code")) %>%
  group_by(LSOA21CD, LAD22CD, LAD22NM) %>%
  summarise(
    imd_decile = if (all(is.na(imd_decile))) NA_integer_ else min(imd_decile, na.rm = TRUE),
    deprivation = "IMD",
    .groups = "drop"
  ) %>%
  rename(
    lsoa21_code = LSOA21CD,
    lad22_code  = LAD22CD,
    lad22_name  = LAD22NM
  )


## Calculate relative risks by lad and sex for all cause mortality

england_lsoa_deaths <- deaths_lsoa_eng_asdr %>% 
  left_join(msoa, by = c("lsoa_code" = "LSOA11CD")) %>% 
  select(lsoa_code, lsoa_name, msoa_code = "MSOA11CD", lad_code = "LAD11CD",
         gender, population_lsoa, deaths_lsoa, stdrate) %>% 
  distinct() %>% 
  left_join(deaths_msoa_eng_asdr %>%  
    select(msoa_code, stdrate_msoa = stdrate, deaths_msoa, gender),
            by = c("msoa_code", "gender")) %>%
  left_join(deaths_lad_eng_asdr %>% 
    select(lad_code, stdrate_lad = stdrate, gender, deaths_lad),
            by = c("lad_code", "gender")) %>% 
  group_by(gender) %>% 
  mutate(
    # Adjust the logic to first check for deaths_lsoa and then deaths_msoa
    stdrate_selected = ifelse(
      deaths_lsoa <= 10 ,            # If LSOA deaths less than 10, use MSOA rate -
      ifelse(deaths_msoa <= 20,     # If MSOA deaths are less than 20, use LAD rate
             stdrate_lad,         
             stdrate_msoa),
      stdrate # Otherwise, use LSOA rate
    ),
    product = stdrate_selected * population_lsoa,  # Calculate product here
    stdrate_ave = sum(product, na.rm = TRUE) / sum(population_lsoa, na.rm = TRUE),  
    RR = stdrate_selected / stdrate_ave  # Calculate RR using the selected rate
  ) %>%
  ungroup()

```

## Apply to life tables, calibrate and smooth

```{r calibrate}
# Apply LSOA relative risks to life table

england_lifetable_lsoa <- england_lsoa_deaths %>% 
  rename(sex = gender) %>% 
  cross_join(england_lifetable) %>% 
  filter(sex.x == sex.y) %>%
  mutate(rate1000=rate1000*RR) %>%
  select(lsoa_code, lsoa_name, gender = sex.x, age, rate1000, population_lsoa,RR)

# Calibration by LAD22 × sex × age-band (NO weights),
# using oa21_lookup (LSOA11 -> LSOA21 -> LAD22 bridge (no weights))

# Standardised life table expanded to lsoas and deaths data
lifetables_england_lsoa_std <- england_lifetable_lsoa %>%
  # dplyr::rename(gender = sex) %>%
  dplyr::mutate(age = as.integer(age),
                rate = rate1000 / 1000) %>%
  dplyr::select(lsoa_code, gender, age, rate)

# Observed deaths by LAD22 × gender × age_band (NO weighting)
obs_by_lad_age <- deaths_england %>%
  dplyr::rename(age_band = age) %>%
  dplyr::inner_join(
    oa21_lookup %>% dplyr::select(LSOA11CD, LAD22CD),
    by = c("lsoa_code" = "LSOA11CD")
  ) %>%
  dplyr::group_by(LAD22CD, gender, age_band) %>%
  dplyr::summarise(observed = sum(deaths, na.rm = TRUE), .groups = "drop")

# Assigned deaths by LAD22 × gender × age_band 
age_to_band <- function(age) {
  dplyr::case_when(
    age >= 0  & age <= 4   ~ "00 to 04",
    age >= 5  & age <= 9   ~ "05 to 09",
    age >= 10 & age <= 14  ~ "10 to 14",
    age >= 15 & age <= 19  ~ "15 to 19",
    age >= 20 & age <= 24  ~ "20 to 24",
    age >= 25 & age <= 29  ~ "25 to 29",
    age >= 30 & age <= 34  ~ "30 to 34",
    age >= 35 & age <= 39  ~ "35 to 39",
    age >= 40 & age <= 44  ~ "40 to 44",
    age >= 45 & age <= 49  ~ "45 to 49",
    age >= 50 & age <= 54  ~ "50 to 54",
    age >= 55 & age <= 59  ~ "55 to 59",
    age >= 60 & age <= 64  ~ "60 to 64",
    age >= 65 & age <= 69  ~ "65 to 69",
    age >= 70 & age <= 74  ~ "70 to 74",
    age >= 75 & age <= 79  ~ "75 to 79",
    age >= 80 & age <= 84  ~ "80 to 84",
    age >= 85              ~ "over 85",
    TRUE ~ NA_character_
  )
}

assigned_by_lad_age <- population_england_syoa %>%
  dplyr::mutate(age = as.integer(age)) %>%
  dplyr::left_join(lifetables_england_lsoa_std,
                   by = c("lsoa_code", "gender", "age")) %>%
  dplyr::mutate(
    rate      = dplyr::coalesce(rate, 0),
    exp_death = population * rate,
    age_band  = as.character(age_to_band(age))
  ) %>%
  dplyr::inner_join(
    oa21_lookup %>% dplyr::select(LSOA11CD, LAD22CD),
    by = c("lsoa_code" = "LSOA11CD")
  ) %>%
  dplyr::group_by(LAD22CD, gender, age_band) %>%
  dplyr::summarise(assigned = sum(exp_death, na.rm = TRUE), .groups = "drop")

# Calibration factors (LAD22 × gender × age_band)
cal_factors_age <- obs_by_lad_age %>%
  dplyr::full_join(assigned_by_lad_age, by = c("LAD22CD", "gender", "age_band")) %>%
  dplyr::mutate(
    factor = dplyr::case_when(
      observed == 0 | assigned == 0 ~ 1,
      assigned > 0 ~ observed / assigned,
      TRUE ~ 1
    )
  ) %>%
  dplyr::select(LAD22CD, gender, age_band, factor, observed, assigned)

# Project LSOA11 lifetable rates to LSOA21 and apply factors (NO weighted mean)
rates_lsoa21_syoa <- lifetables_england_lsoa_std %>%
  dplyr::inner_join(
    oa21_lookup %>% dplyr::select(LSOA11CD, LSOA21CD, LAD22CD, LAD22NM),
    by = c("lsoa_code" = "LSOA11CD")
  ) %>%
  dplyr::group_by(LSOA21CD, LAD22CD, LAD22NM, gender, age) %>%
  dplyr::summarise(rate = mean(rate, na.rm = TRUE), .groups = "drop") %>%
  dplyr::mutate(age_band = as.character(age_to_band(age))) %>%
  dplyr::rename(lsoa21cd = LSOA21CD)

england_lsoa21_syoa_cal <- rates_lsoa21_syoa %>%
  dplyr::left_join(cal_factors_age, by = c("LAD22CD","gender","age_band")) %>%
  dplyr::mutate(rate_cal = rate * factor) %>%
  dplyr::select(lsoa21cd, LAD22CD, LAD22NM, age, age_band, gender, rate, factor, rate_cal)


# Calibration checks
lad_names <- oa21_lookup %>% dplyr::select(LAD22CD, LAD22NM) %>% dplyr::distinct()

# Population LSOA21 (NO weighting)
pop21_syoa <- population_england_syoa %>%
  dplyr::mutate(age = as.integer(age)) %>%
  dplyr::inner_join(
    oa21_lookup %>% dplyr::select(LSOA11CD, LSOA21CD, LAD22CD),
    by = c("lsoa_code" = "LSOA11CD")
  ) %>%
  dplyr::transmute(
    lsoa21cd = LSOA21CD,
    LAD22CD,
    gender,
    age,
    population
  )

exp_by_lad_gender_ageband <- pop21_syoa %>%
  dplyr::mutate(age_band = as.character(age_to_band(age))) %>%
  dplyr::left_join(
    england_lsoa21_syoa_cal %>% dplyr::select(lsoa21cd, gender, age, age_band, rate_cal),
    by = c("lsoa21cd","gender","age","age_band")
  ) %>%
  dplyr::mutate(exp_deaths_cal = population * dplyr::coalesce(rate_cal, 0)) %>%
  dplyr::group_by(LAD22CD, gender, age_band) %>%
  dplyr::summarise(assigned_cal = sum(exp_deaths_cal, na.rm = TRUE), .groups = "drop")

check_by_lad_gender_age <- obs_by_lad_age %>%
  dplyr::left_join(exp_by_lad_gender_ageband, by = c("LAD22CD","gender","age_band")) %>%
  dplyr::mutate(
    assigned_cal = dplyr::coalesce(assigned_cal, 0),
    diff         = assigned_cal - observed,
    pct_diff     = dplyr::if_else(observed > 0, 100 * diff / observed, NA_real_)
  )

check_england_total <- check_by_lad_gender_age %>%
  dplyr::summarise(
    observed     = sum(observed, na.rm = TRUE),
    assigned_cal = sum(assigned_cal, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  dplyr::mutate(
    area = "England (all LAD22)",
    diff = assigned_cal - observed,
    pct_diff = ifelse(observed > 0, 100 * diff / observed, NA_real_)
  ) %>%
  dplyr::select(area, observed, assigned_cal, diff, pct_diff)

print(check_england_total)

```

```{r smooth}
# Smooth, as calibration results in some jumps (need to check again after smoothing it matches observed) - takes about 50 minutes

england_lsoa21_syoa_smoothed <- england_lsoa21_syoa_cal %>%
  rename(sex = gender) %>%
  arrange(lsoa21cd, sex, age) %>%
  group_by(lsoa21cd, sex) %>%
  group_modify(~{
    df  <- .x
    eps <- 1e-9

    # default: no change
    df$rate_smooth <- df$rate

    idx_ge5 <- df$age >= 20 & is.finite(df$rate) & is.finite(df$age)

    if (sum(idx_ge5) >= 7) {
      fit <- mgcv::gam(
        log(pmax(rate, eps)) ~ s(age, k = 7),   # lower k -> smoother; higher k -> more detail
        data   = df[idx_ge5, , drop = FALSE],
        method = "REML",
        select = TRUE
      )

      df$rate_smooth[idx_ge5] <- exp(predict(fit, newdata = df[idx_ge5, , drop = FALSE]))

      # --- Rescale to preserve overall rate level over ages >= 5 (no population available) ---
      # Keeps sum (and thus the mean) of rates for 5+ unchanged
      sum_orig   <- sum(df$rate[idx_ge5], na.rm = TRUE)
      sum_smooth <- sum(df$rate_smooth[idx_ge5], na.rm = TRUE)
      sf <- if (is.finite(sum_smooth) && sum_smooth > 0) sum_orig / sum_smooth else 1

      df$rate_smooth[idx_ge5] <- df$rate_smooth[idx_ge5] * sf
    }

    df$rate1000 <- df$rate_smooth * 1000
    df
  }) %>%
  ungroup()

# join IMD
england_lsoa21_syoa_smoothed <- england_lsoa21_syoa_smoothed %>%
  left_join(deprivation_lsoa21 %>% 
              dplyr::select(lsoa21cd = lsoa21_code, imd_decile), 
            by= "lsoa21cd")

# Smoothing checks (repeat calibration checks above for smoothed data)

rates_sm <- england_lsoa21_syoa_smoothed %>%
  dplyr::mutate(
    gender = sex,
    age    = as.integer(age)
  ) %>%
  # choose best available rate column (per person)
  dplyr::mutate(
    rate_use = dplyr::case_when(
      !is.null(.data$rate_smooth) ~ .data$rate_smooth,
      is.null(.data$rate_smooth) & !is.null(.data$rate) ~ .data$rate,
      is.null(.data$rate_smooth) & is.null(.data$rate) & !is.null(.data$rate1000) ~ (.data$rate1000 / 1000),
      TRUE ~ NA_real_
    )
  ) %>%
  dplyr::select(lsoa21cd, gender, age, rate_use)

# Expected deaths by LAD × gender × age-band (using smoothed rate) 
exp_by_lad_gender_ageband_sm <- pop21_syoa %>%
  dplyr::mutate(age_band = as.character(age_to_band(age))) %>%
  dplyr::left_join(
    rates_sm %>% dplyr::mutate(age_band = as.character(age_to_band(age))),
    by = c("lsoa21cd","gender","age","age_band")
  ) %>%
  dplyr::mutate(exp_deaths_sm = population * dplyr::coalesce(rate_use, 0)) %>%
  dplyr::group_by(LAD22CD, gender, age_band) %>%
  dplyr::summarise(assigned_sm = sum(exp_deaths_sm, na.rm = TRUE), .groups = "drop")

#  Compare to observed by LAD × gender × age-band
check_by_lad_gender_age_sm <- obs_by_lad_age %>%
  dplyr::left_join(exp_by_lad_gender_ageband_sm, by = c("LAD22CD","gender","age_band")) %>%
  dplyr::mutate(
    assigned_sm = dplyr::coalesce(assigned_sm, 0),
    diff        = assigned_sm - observed,
    pct_diff    = dplyr::if_else(observed > 0, 100 * diff / observed, NA_real_)
  )

#  England total
check_england_total_sm <- check_by_lad_gender_age_sm %>%
  dplyr::summarise(
    observed   = sum(observed,   na.rm = TRUE),
    assigned   = sum(assigned_sm, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  dplyr::mutate(
    area    = "England (all LAD22)",
    diff    = assigned - observed,
    pct_diff = ifelse(observed > 0, 100 * diff / observed, NA_real_)
  ) %>%
  dplyr::select(area, observed, assigned, diff, pct_diff)

print(check_england_total_sm)

# Check per-age-band summary, England-wide
check_england_by_ageband_sm <- check_by_lad_gender_age_sm %>%
  dplyr::group_by(age_band) %>%
  dplyr::summarise(
    observed = sum(observed, na.rm = TRUE),
    assigned = sum(assigned_sm, na.rm = TRUE),
    diff     = assigned - observed,
    pct_diff = ifelse(observed > 0, 100 * diff / observed, NA_real_),
    .groups  = "drop"
  )
View(check_england_by_ageband_sm)


# Save calibrated & smoothed output with imd
saveRDS(england_lsoa21_syoa_smoothed,
  here::here("health_data/processed/england_lsoa21_mxrates.rds"))

```


## Lifetable by IMD

```{r livetable-imd}

# stretch population table to cover ages 0 to 100 (age '90' is in fact 90+, so
# this imputes the '90' value to each year 90 to 100) - inflates pop numbers for 
# 90+, but that's OK as they are used for weighting by year of age, not to 
# calculate total population

# SP NOTE: could replace this with 2023 population, as in disease below

# calculate total pop
age_90_data <- pop21_syoa %>% filter(age == 90) 

# Create new rows for ageyr 96 to 100, repeating the values for val_interpolated
new_rows <- age_90_data %>%
  mutate(age = list(91:100)) %>%
  unnest(age) 

# combine with population to age 90
pop_stretched <- bind_rows(pop21_syoa, new_rows) %>%
  rename(sex = gender) %>%
  dplyr::select(-LAD22CD)

# lifetable by IMD, based on calibrated results
england_lifetable_imd <- england_lsoa21_syoa_smoothed %>%
  dplyr::select(lsoa21cd, sex, age, rate1000, imd_decile) %>%
  
  # join population
  left_join(pop_stretched, by = c("lsoa21cd",  "sex", "age")) %>%
  
  # remove where zero population
  filter(population > 0) %>%
  
  # aggregate to IMD
  group_by(imd_decile, age, sex) %>%
  summarise(rate1000 = weighted.mean(rate1000, w = population),
            population = sum(population),
            .groups = "drop")

# save output
saveRDS(england_lifetable_imd, here("health_data/processed/england_imd_mxrates.rds"))

```


## Graphs for checking results

### Deaths rates for England

```{r graph-death-england}
# Graph death rates england

### Graph for England
# imd_decile is a factor

data_plot <- england_lsoa21_syoa_smoothed %>%
  mutate(imd_decile = as.factor(imd_decile))  # Ensure imd_decile is a factor

p_england <- ggplot(data_plot, 
                    aes(x = age, y = rate1000,
                        col = imd_decile,  # Color by IMD decile
                        group = lsoa21cd)) +  # Each LSOA has its own line
  geom_line(lwd = 0.7, alpha = 0.5) +  # Reduce opacity to manage overplotting
  facet_wrap(~ sex) +  # Compare IMD deciles within each sex
  ylab("Mortality rate (per 1000)") + 
  xlab("Age (years)") +  
  scale_y_continuous(trans = "log", breaks = c(0.2, 0.5, 1, 5, 10, 50, 100, 200)) +
  scale_color_viridis_d(option = "C", name = "IMD Decile") +  # Use discrete color scale
  theme_minimal(base_size = 14) +  
  theme(
    strip.text = element_text(face = "bold"),
    legend.position = "bottom"  # Move legend for readability
  ) +
  ggtitle("Death rates England")  # Add title

# Print the plot
print(p_england)

# interactive_p_england <- ggplotly(p_england)  ## SP: SLOW AND CRASHES
```

### Deaths rates for England by LAD and IMD


```{r graph-death-imd}
# Graph death rates England by IMD

data_plot_imd <- england_lifetable_imd %>%
  mutate(imd_decile = as.factor(imd_decile))  # Ensure imd_decile is a factor

p_imd<- ggplot(data_plot_imd, 
                   aes(x = age, y = rate1000,
                       col = imd_decile,  # Color by imd_decile
                       group = imd_decile)) +  # Each imd_decile has its own line
  geom_line(lwd = 0.7, alpha = 0.5) +  # Reduce opacity to manage overplotting
  facet_wrap(~ sex) +  # Compare IMD deciles within each sex
  ylab("Mortality rate (per 1000)") + 
  xlab("Age (years)") +  
  scale_y_continuous(trans = "log", breaks = c(0.2, 0.5, 1, 5, 10, 50, 100, 200)) +
  scale_color_viridis_d(option = "C", name = "IMD Decile") +  # Use discrete color scale
  theme_minimal(base_size = 14) +  
  theme(
    strip.text = element_text(face = "bold"),
    legend.position = "bottom"  # Move legend for readability
  ) +
  ggtitle("Death rates England by IMD decile")  # Add title

# Print the plot
print(p_imd)

```

### Comparison with publicly available estimates by LADs and sex

Comparison of age standardised rates with ONS data by LAD and our
calculations but using weight from the European standard population. We
use European standard population to compare because ASDR per LAD from
ONS use this weights in their calculations.

stdr_rate ons is publised, stdr_rate_eng is calculated by us using
England population weights and stdr_rate_eu is our estimates using
European standard population weights. Our estimates using European
standard rates compare with published ONS rates.

```{r death-compare}

# Comparison using English weights. Belen note (07/11/2025) after checking results using english weights and Euro weights, data aligns with published estimates with Euro weights, so using those, using english weights pushes all rates down. 

# Calculate LAD ASR using english weights

deaths_lad_asdr_compare <- compute_asdr(
  df_deaths = deaths_lad %>% group_by(lad_code, lad_name, gender, age) %>%
    summarise(deaths = sum(deaths, na.rm = TRUE), .groups = "drop"),
  df_pop    = population_lad %>% group_by(lad_code, lad_name, gender, age) %>%
    summarise(population = sum(population, na.rm = TRUE), .groups = "drop"),
  by_keys   = c("lad_code","lad_name","gender","age"), weights = population_weights_England
) %>% rename(deaths_lad = deaths_geo)

deaths_lad_eng_weights <- deaths_lad_asdr_compare %>%
  select(lad_name, gender, stdrate_eng = stdrate)

deaths_lad_eur_weights <- deaths_lad_eng_asdr %>% # now uses european weights
    select(lad_name, gender, stdrate_eu = stdrate)

# Comparison with NOMIS (expects `nomis_lad` with lad_name & gender)
comparison_table <- nomis_lad %>% 
  filter(lad_name %in% deaths_lad_eng_weights$lad_name) %>%  # remove welsh
  left_join(deaths_lad_eng_weights, by = c("gender","lad_name")) %>% 
  left_join(deaths_lad_eur_weights,  by = c("gender","lad_name"))

print(comparison_table)

```



# Disease Incidence and Prevalence

For a list of diseases related to the modeled health risk factors
including physical activity, air pollution (PM25 and NO2), noise and
greenspace, we need incidence rates by age, sex and also by LAD
(available from GBD). We also need prevalence to assign initial health
state in the model. The main data transformations were to:

1\) interpolate from 5 year age groups to 1.

2\) Adjust colon and rectum cancers to only reflect on colon cancer
proportion.

3\) Adjust Tracheal, bronchus, and lung cancer to only reflect on lung
cancer.

4\) Replace rates for LADs with small numbers of incidence and
prevalence with higher level data for Greater Manchester.

## Data sources

Diseases for all of England by 5-year age bands and sex for year 2023 from GBD, downloaded 12-Oct-25.

<https://vizhub.healthdata.org/gbd-results/>

    Parameters:
    - GBD Estimate - Cause of death or injury
    - Measure: Incidence, Prevalence
    - Metric: Number, Percent, Rate
    - Cause: Stroke, Ischemic heart disease, Breast cancer, Uterine cancer, Tracheal, bronchus and lung cancer, Colon and rectum cancer, Esophageal cancer, Liver cancer, Stomach cancer, Chronic myeloid leukemia, Multiple myeloma, Larynx cancer, Lip and oral cavity cancer, Nasopharynx cancer, Other pharynx cancer, Bladder cancer, Depressive disorders, Alzheimer’s disease and other dementias, Diabetes mellitus type 2, Parkinson's diseasee [total 20]
    - Location: England
    - Age: <5, 5-9, 10-14, … 90-94, 95+ [total 20]
    - Sex: Female, Male
    - Year: 2023
    - Names (not IDs)

For colon cancer, in the absence of estimated for England, we adjusted incidence and prevalence based on estimates from the American Cancer Society (<https://www.cancer.org/cancer/types/colon-rectal-cancer/about/key-statistics.html>, accessed 12-Oct-25). Estimates for 2025 are 107,320 new cases of colon cancer and 46,950 estimates of rectal cancer.  We assume that 70% of Colon and rectum cancer is colon cancer for both incidence and prevalence

For lung cancer, we compare total Tracheal, bronchus, and lung cancer incidence for 2021 from GBD data (<https://vizhub.healthdata.org/gbd-results/>, accessed 12-Oct-25) with England lung cancer incidence statistics for 2021 (<https://digital.nhs.uk/data-and-information/publications/statistical/cancer-registration-statistics/england-2021---summary-counts-only/cancer-incidence>, accessed 12-Oct-25). GBD estimates 37,682 incident cases of Tracheal, bronchus, and lung cancer and estimates from England indicate 20,312. We assume that 54% of Tracheal, bronchus, and lung cancer is lung  cancer for both incidence and prevalence.

```{r cleanup-disease}
# disease data creates a large table, so begin by cleaning up everything except 
# what will be required for the table

rm(list = setdiff(ls(), 
                  c(lsf.str(), ## keeps functions
                    "england_lsoa_deaths", "deprivation_lsoa21",
                    "pop_england_syoa_2023")))

```


```{r gbd-data}
# GBD data for all of England
gbd <- readr::read_csv(unzip(here("health_data/original/gbd/IHME-GBD_2023_DATA-4a0d002f-1.zip"),
                                  "IHME-GBD_2023_DATA-4a0d002f-1.csv"))

## if that is saving unwanted files, substitute:
# csvfile <- unzip(here("health_data/original/gbd/IHME-GBD_2023_DATA-4a0d002f-1.zip"),
#                  "IHME-GBD_2023_DATA-4a0d002f-1.csv")
# gbd <- read_csv(csvfile)
# file.remove(csvfile)

gbdp <- gbd_process(gbd, year = 2023) %>%
  filter(measure %in% c("Prevalence", "Incidence"))

```


## Interpolation

Plots comparing gbd incidence rates before and after interpolation are saved in the `images/inc_gbd_age_sex` folder.  

```{r gbd-interpolation}
# Now stretch the data out using an index, to create a data frame with 1 row per year of age and create a variable for year of age. 
# The age group rate repeats within single years of age in the group. 
index <- rep(1:nrow(gbdp), gbdp$agediff)
gbdpyrd5 <- gbdp[index,] %>%
  mutate(ageyr = from_age + sequence(gbdp$agediff) - 1) %>%
  select(measure, ageyr, sex, agegroup, from_age, to_age, cause, year, val1yr,rate_1, location) 

# Apply the disaggregation function

# Group data for dissaggregation 

gbdp_grp <- gbdp %>%
  group_by(measure, year, sex, cause, location) %>%
  arrange(measure, year, sex, cause, from_age) 


# Apply function (select a function from 'functions/interpolation.R'). Smooth_spline does a good job.
gbdpyr_interp <- group_modify(gbdp_grp, disagg_smooth_spline) %>%
  ungroup()

# Filter the rows where ageyr is 95
age_95_data <- gbdpyr_interp %>% filter(ageyr == 95)

# Create new rows for ageyr 96 to 100, repeating the values for val_interpolated
new_rows <- age_95_data %>%
  mutate(ageyr = list(96:100)) %>%
  unnest(ageyr) 

# Combine the original data frame with the new rows
gbdpyr_interp <- bind_rows(gbdpyr_interp, new_rows)

rm(new_rows, age_95_data)

# Join with original data where rates are the same within groups to validate interpolated data
gbdpyr_interp <- gbdpyr_interp %>%
  left_join(gbdpyrd5, by = c("measure", "year", "ageyr", "sex", "cause", "location"))

# Plot data to check interpolated values against 5-year age group values (original data)
## Four interpolation function could be use, the best fit should be used. For now, best fit to the data assessed visually.

# # # Melt the data to long format for ggplot
plot_data <- gbdpyr_interp %>%
  select(measure, cause, sex, ageyr, rate_1, val_interpolated, location) %>%
  pivot_longer(cols = c(rate_1, val_interpolated), names_to = "type", values_to = "value")

# Define output directory
output_dir <- "health_data/images/inc_gbd_age_sex/"
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

# Get unique combinations of measure, cause, sex, and location
combinations <- plot_data %>%
  distinct(measure, cause, sex, location)

# Generate and save plots for each combination
for (i in 1:nrow(combinations)) {
  subset_df <- plot_data %>%
    filter(measure == combinations$measure[i],
           cause == combinations$cause[i],
           sex == combinations$sex[i],
           location == combinations$location[i])
  p <- ggplot(subset_df, aes(x = ageyr, y = value, color = type)) +
    geom_line() +
    labs(title = paste("Measure:", combinations$measure[i],
                       "Cause:", combinations$cause[i],
                       "Sex:", combinations$sex[i],
                       "Location:", combinations$location[i]),
         x = "Age (years)",
         y = "Value") +
    theme_minimal(base_family = "Arial") +
    theme(panel.background = element_rect(fill = "white", color = "white"),
          plot.background = element_rect(fill = "white", color = "white"))
# # Save the plot
  ggsave(filename = paste0(output_dir, "plot_", i, ".png"), plot = p, width = 8, height = 6)
}
```

## Apply relative risks and add deprivation data

We apply the relative risks for each LSOA to the disease data.  We assume that the relative risks calculated above for mortality apply also to disease. *[This assumption may be reconsidered further.]*

```{r gbd-relative-risk}

# Clean up again before creating large table
rm(list = setdiff(ls(), 
                  c(lsf.str(), ## keeps functions
                    "england_lsoa_deaths", "deprivation_lsoa21",
                    "pop_england_syoa_2023", "gbdpyr_interp")))

# Apply LSOA relative risks (as calculated for deaths) to disease data
england_diseasetable_lsoa_imd <- gbdpyr_interp %>%
  mutate(sex = recode(sex, "Female" = "Females", "Male" = "Males")) %>%
  dplyr::select(measure, sex, cause, age = ageyr, rate = val_interpolated) %>%
  left_join(england_lsoa_deaths %>%
              dplyr::select(lsoa_code, lsoa_name, sex = gender, RR),
            by = "sex", relationship = "many-to-many") %>%
  mutate(rate1000 = rate * 1000 * RR) %>%
  select(measure, lsoa_code, lsoa_name, cause, sex, age, rate1000, RR) %>%
  # join deprivation data
  left_join(deprivation_lsoa21 %>% dplyr::select(lsoa21_code, imd_decile), 
            by = c("lsoa_code" = "lsoa21_code"))

# save output with IMD 
saveRDS(england_diseasetable_lsoa_imd, 
        here("health_data/processed/england_lsoa21_diseaserates.rds"))

```

## Disease rates by IMD

```{r disease-imd}

# stretch population table to cover ages 0 to 100 (age '90' is in fact 90+, so
# this imputes the '90' value to each year 90 to 100) - inflates pop numbers for 
# 90+, but that's OK as they are used for weighting by year of age, not to 
# calculate total population

# calculate total pop
age_90_data <- pop_england_syoa_2023 %>% filter(age == 90)

# Create new rows for ageyr 96 to 100, repeating the values for val_interpolated
new_rows <- age_90_data %>%
  mutate(age = list(91:100)) %>%
  unnest(age) 

# combine with population to age 90
pop_stretched <- bind_rows(pop_england_syoa_2023, new_rows) %>%
  dplyr::select(-lsoa_name)


# disease table by IMD
england_diseasetable_imd <- england_diseasetable_lsoa_imd %>%
  
  # join population
  left_join(pop_stretched, by = c("lsoa_code", "sex", "age")) %>%
  
  # remove where zero population
  filter(population > 0) %>%
  
  # aggregate to IMD
  group_by(measure, cause, imd_decile, age, sex) %>%
  summarise(rate1000 = weighted.mean(rate1000, w = population),
            population = sum(population),
            .groups = "drop")

# save output
saveRDS(england_diseasetable_imd, 
        here("health_data/processed/england_imd_diseaserates.rds"))

```

## Graphs for checking results

``` {r disease-graph-cleanup}
# Clean up again before creating graphs from large table
rm(list = setdiff(ls(), 
                  c(lsf.str(), ## keeps functions
                    "england_diseasetable_lsoa_imd",
                    "england_diseasetable_imd")))

incidence_lsoa <- england_diseasetable_lsoa_imd %>% filter(measure == "Incidence")
prevalence_lsoa <- england_diseasetable_lsoa_imd %>% filter(measure == "Prevalence")
rm(england_diseasetable_lsoa_imd)

```

### Disease incidence rates for England

Plots of disease incidence rates by LSOA are saved in the `images/inc_lsoa_age_sex` folder.  

```{r graph-incidence}

# graphs of incidence of disease rates, by lsoa

# Define output directory
output_dir <- "health_data/images/inc_lsoa_age_sex/"
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

for (i in unique(incidence_lsoa$cause)) {
  data_plot <- incidence_lsoa %>%
    filter(cause == i) %>%
    mutate(imd_decile = as.factor(imd_decile)) %>%
    filter(!is.na(imd_decile))
  
  plot_title <- paste("Disease incidence rates for England:", i)
  
  p <- ggplot(data_plot,
              aes(x = age, y = rate1000,
                  col = imd_decile, # colour by IMD decile
                  group = lsoa_code)) +  # each LSOA has its own line
    geom_line(lwd = 0.7, alpha = 0.5) +
    facet_wrap (~ sex) +
    ylab("Disease incidence rate (per 1000)") +
    xlab("Age (years)") +
    scale_y_continuous(trans = "log", breaks = c(0.2, 0.5, 1, 5, 10, 50, 100, 200)) +
    scale_color_viridis_d(option = "C", name = "IMD Decile") +  # Use discrete color scale
    theme_bw(base_size = 14) +  
    theme(
      strip.text = element_text(face = "bold"),
      legend.position = "bottom"  ) +
    ggtitle(plot_title)  
  
  # Save the plot
  ggsave(filename = here(paste0(output_dir, "plot_", i, ".png")), plot = p, width = 12, height = 6)

}

```

### Disease incidence rates for England by IMD

Plots of disease incidence rates for IMD deciles are saved in the `images/inc_imd_age_sex` folder.  

```{r graph-incidence-imd}

# graphs of incidence of disease rates, by imd groups

# Define output directory
output_dir <- "health_data/images/inc_imd_age_sex/"
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

for (i in unique(england_diseasetable_imd$cause)) {
  data_plot <- england_diseasetable_imd %>%
    filter(measure == "Incidence" & cause == i) %>%
    mutate(imd_decile = as.factor(imd_decile)) %>%
    filter(!is.na(imd_decile))
  
  plot_title <- paste("Disease incidence rates for England by IMD decile:", i)
  
  p <- ggplot(data_plot,
              aes(x = age, y = rate1000,
                  col = imd_decile, # colour by IMD decile
                  group = imd_decile)) +  # each imd_decile has its own line
    geom_line(lwd = 0.7, alpha = 0.5) +
    facet_wrap (~ sex) +
    ylab("Disease incidence rate (per 1000)") +
    xlab("Age (years)") +
    scale_y_continuous(trans = "log", breaks = c(0.2, 0.5, 1, 5, 10, 50, 100, 200)) +
    scale_color_viridis_d(option = "C", name = "IMD Decile") +  # Use discrete color scale
    theme_bw(base_size = 14) +  
    theme(
      strip.text = element_text(face = "bold"),
      legend.position = "bottom"  ) +
    ggtitle(plot_title)  
  
  # Save the plot
  ggsave(filename = here(paste0(output_dir, "plot_", i, "_imd.png")), plot = p, width = 12, height = 6)

}

```

### Disease prevalence rates for England

Plots of disease prevalence rates by LSOA are saved in the `images/prev_lsoa_age_sex` folder.  

```{r graph-prevalence}

# graphs of prevalence of disease rates, by lsoa

# Define output directory
output_dir <- "health_data/images/prev_lsoa_age_sex/"
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

for (i in unique(prevalence_lsoa$cause)) {
  data_plot <- prevalence_lsoa %>%
    filter(cause == i) %>%
    mutate(imd_decile = as.factor(imd_decile)) %>%
    filter(!is.na(imd_decile))
  
  plot_title <- paste("Disease prevalence rates for England:", i)
  
  p <- ggplot(data_plot,
              aes(x = age, y = rate1000,
                  col = imd_decile, # colour by IMD decile
                  group = lsoa_code)) +  # each LSOA has its own line
    geom_line(lwd = 0.7, alpha = 0.5) +
    facet_wrap (~ sex) +
    ylab("Disease prevalence rate (per 1000)") +
    xlab("Age (years)") +
    scale_y_continuous(trans = "log", breaks = c(0.2, 0.5, 1, 5, 10, 50, 100, 200)) +
    scale_color_viridis_d(option = "C", name = "IMD Decile") +  # Use discrete color scale
    theme_bw(base_size = 14) +  
    theme(
      strip.text = element_text(face = "bold"),
      legend.position = "bottom"  ) +
    ggtitle(plot_title)  
  
  # Save the plot
  ggsave(filename = here(paste0(output_dir, "plot_", i, ".png")), plot = p, width = 12, height = 6)

}

```

### Disease prevalence rates for England by IMD

Plots of disease prevalence rates for IMD deciles are saved in the `images/prev_imd_age_sex` folder.  

```{r graph-prevalence-imd}

# graphs of prevalence of disease rates, by imd groups

# Define output directory
output_dir <- "health_data/images/prev_imd_age_sex/"
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

for (i in unique(england_diseasetable_imd$cause)) {
  data_plot <- england_diseasetable_imd %>%
    filter(measure == "Prevalence" & cause == i) %>%
    mutate(imd_decile = as.factor(imd_decile)) %>%
    filter(!is.na(imd_decile))
  
  plot_title <- paste("Disease prevalence rates for England by IMD decile:", i)
  
  p <- ggplot(data_plot,
              aes(x = age, y = rate1000,
                  col = imd_decile, # colour by IMD decile
                  group = imd_decile)) +  # each imd_decile has its own line
    geom_line(lwd = 0.7, alpha = 0.5) +
    facet_wrap (~ sex) +
    ylab("Disease prevalence rate (per 1000)") +
    xlab("Age (years)") +
    scale_y_continuous(trans = "log", breaks = c(0.2, 0.5, 1, 5, 10, 50, 100, 200)) +
    scale_color_viridis_d(option = "C", name = "IMD Decile") +  # Use discrete color scale
    theme_bw(base_size = 14) +  
    theme(
      strip.text = element_text(face = "bold"),
      legend.position = "bottom"  ) +
    ggtitle(plot_title)  
  
  # Save the plot
  ggsave(filename = here(paste0(output_dir, "plot_", i, "_imd.png")), plot = p, width = 12, height = 6)

}

```



# Combining All-cause Mortality and Disease Incidence Data (by IMD deciles)

Saves the files required by the health model: `health_transitions_prevalence.csv` and `health_transitions_raw.csv`.  *[To confirm that 'raw' is correct.]*

```{r cleanup-combination}

# clean up to remove large tables
rm(list = setdiff(ls(), lsf.str()))  # keep functions

```


```{r combination}

diseases <- readRDS(here("health_data/processed/england_imd_diseaserates.rds"))
allcause <- readRDS(here("health_data/processed/england_imd_mxrates.rds"))

# Process data ## CHECK THAT CONVERSION OF rate1000 TO rate IS CORRECT

allcause<- allcause %>%
  mutate(cause = "all_cause_mortality",
         measure = "deaths") %>%
  mutate(sex = case_when(sex == "Males" ~ "male",
                         sex == "Females" ~ "female"),
         location_code = imd_decile, 
         age = as.numeric(age)) %>% 
  dplyr::select(age, sex, location_code, cause, rate = rate1000, measure) %>%
  mutate(location_type = "imd_decile")

diseases <- diseases %>% 
  mutate(measure = tolower(measure),
         cause = tolower(cause),
         socio = NA) %>% 
  mutate(sex = case_when(sex == "Males" ~ "male",
                                 sex=="Females" ~ "female"),
         location_code = imd_decile,
         age = as.numeric(age)) %>%
  dplyr::select(age, sex, location_code, cause, rate = rate1000, measure) %>%
  mutate(location_type = "imd_decile")

incidence <- diseases %>% filter(measure == "incidence") 
prevalence <- diseases %>% filter(measure == "prevalence") %>%
  mutate(sex=case_when(sex == "male" ~ 1, 
                       sex == "female" ~ 2))

health_transitions <- bind_rows(allcause, incidence)

# Save prevalence and incidence (includes deaths from all causes) separately

write.csv(prevalence, here("health_data/processed/health_transitions_prevalence.csv"),
          row.names = FALSE)

write.csv(health_transitions, here("health_data/processed/health_transitions_raw.csv"),
          row.names = FALSE) ### DOES SOMETHING ELSE HAPPEN TO 'RAW'?
```
