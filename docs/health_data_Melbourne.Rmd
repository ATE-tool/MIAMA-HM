---
title: "health data Melbourne"
author: "Chris Jackson Belen Zapata-Diomedi, Steve Pemberton"
email: "mbzd2@cam.ac.uk", "chris.jackson@mrc-bsu.cam.ac.uk", "steve.pemberton@rmit.edu.au"
date: today
format: 
  html:
    code-fold: true
    embed-resources: true
    df-print: paged
execute: 
    message: false
    warning: false
toc: true
number-sections: true
editor: visual
  markdown: 
    wrap: 72
---

# Introduction

This document explains and produces estimates for the health model for JIBE Melbourne. The model, initially has three stages where individuals are in a healthy state, might become disease and die from any causes (regardless health status). For this first iteration of the model we need estimates of incidence and all cause mortality. A second iteration will be to include prevalence of disease at baseline (as opposed to all individuals being healthy) and add a differential all cause mortality risk for individuals who have one or more diseases.

We need data for all cause mortality and diseases incidence. For disease incidence data is required for the list of diseases below, which correspond to the included risk factors in the model (PM2.5, NO2, physical activity).

ADD diseases list here. TO DO.

In Jibe we aim to represent inequalities in health, thus, we include inequalities in our estimates of health to the extend of this being possible using publicly available data.

# Incidence data

## Incidence data by age and sex

We use GBD data as the age and sex data for incidence estimates except for cancers. For cancers we use Australian Institute of Health and Welfare (AIHW) data and for mortality Australian Bureau of statistic (ABS) data.

### Global Burden of disease data for Australia: data interpolation

Prepare incidence data by sex and single year of age. To do so, we interpolate the data between age groups. Four interpolation functions are available below to test which one fits the data best. Graphs are created and saved in docs/images/data_prep to visualy check the fit of the interpolation to the original data.

```{r}

library(dplyr)
library(tidyr)
library(ggplot2)

# Avoid scientific notation
options("scipen"=100, "digits"=4)

# GBD data for Melbourne. 
gbd <- read.csv("health/original/GBD/gbd_incidence.csv")

# Filter data to needed variables and remove strings from GBD age variable and create from_age and to_age needed for interpolation. 

gbdp <- gbd %>%
  filter(measure %in% "Incidence") %>%
  filter(metric %in% "Rate") %>%
  filter(year %in% 2018) %>%
  select(-c(location, upper, lower)) %>%
  filter(!cause %in% "All causes") %>%
  mutate(rate_1=val/100000) %>% 
  # some ages have 'years' (eg 5-9 years), while others don't (eg 80-84); omit 'years'
  mutate(age = gsub(" years", "", age)) %>%
  tidyr::extract(age, c("from_age", "to_age"), "(.+)-(.+)", remove=FALSE, convert=TRUE) %>%
  mutate(from_age = case_when(age=="95+"  ~  95L,
                              age=="<5"  ~  0L,
                              TRUE  ~  from_age),
         to_age = case_when(age=="95+"  ~  99L,
                            age=="<5"  ~  4L,
                            TRUE  ~  to_age),
         agediff = to_age - from_age + 1,
          val1yr = rate_1) %>% 
  #we do not distribute amongst age groups as it is a rate but assume same within age group
 rename(agegroup = age) 


# Now stretch the data out using an index, to create a data frame with 1 row per year of age and create a variable for year of age. The age group rate repeats within single years of age in the group. 
index <- rep(1:nrow(gbdp), gbdp$agediff)
gbdpyrd5 <- gbdp[index,] %>%
  mutate(ageyr = from_age + sequence(gbdp$agediff) - 1)
gbdpyrd5 <- gbdpyrd5 %>% 
  select(measure, ageyr, sex, agegroup, from_age, to_age, cause, year, val1yr,rate_1) 


# Interpolation function to create smooth data (Steve: Might move to a function folder, but need to ensure all data to interpolate has the same format)

# Spline

library(splines)

disagg_spline <- function(dat, key) {
  epsilon <- 1e-6  # Small constant to avoid log(0)
  
  with(dat, {
    # Define the x and y for interpolation
    x <- seq(from = floor(min(from_age)/5) * 5, to = 100, by = 5)
    
    # browser() #useful for checking that x is what we expect. Can be used at any steps that we want 
    # to check the data and works when running the function by stoping the process.
    
    # Add epsilon and log-transform the rates
    y <- log(rate_1 + epsilon)
    
    # Generate new x points (high-frequency), constrained to be at most 99
    new_x <- seq(min(x), min(99, max(x)), length.out = min(100, max(x) - min(x) + 1))
    
     # browser()
    
    # Perform spline interpolation on the log-transformed data
    log_interpolated <- spline(x, y, xout = new_x)$y
    
    # Transform back from log scale by exponentiating
    interpolated <- exp(log_interpolated) 
    
    # Ensure that negative values do not occur after transformation
    interpolated[interpolated < 0] <- 0
    
    # Create a data frame with the interpolated values
    data.frame(
      ageyr = new_x,
      val_interpolated = interpolated
    )
  })
}

# Polinomial

disagg_polynomial <- function(dat, key) {
  with(dat, {
    x <- seq(from = floor(min(from_age)/5) * 5, to = 100, by = 5)
    y <- rate_1
    
    # Fit a polynomial model
    fit <- lm(y ~ poly(x, 3))  # 3rd-degree polynomial (adjust degree as needed)
    
    # Generate new x points
    new_x <- seq(min(x), min(99, max(x)), length.out = min(100, max(x) - min(x) + 1))
    
    # Predict values
    interpolated <- predict(fit, newdata = data.frame(x = new_x))
    
    # Ensure that negative values do not occur
    interpolated[interpolated < 0] <- 0
    
    # Create a data frame with the interpolated values
    data.frame(
      ageyr = new_x,
      val_interpolated = interpolated
    )
  })
}

##Loess

disagg_loess <- function(dat, key) {
  with(dat, {
    x <- seq(from = floor(min(from_age)/5) * 5, to = 100, by = 5)
    y <- rate_1
    
    # Fit a loess model
    fit <- loess(y ~ x)
    
    # Generate new x points
    new_x <- seq(min(x), min(99, max(x)), length.out = min(100, max(x) - min(x) + 1))
    
    # Predict values
    interpolated <- predict(fit, newdata = data.frame(x = new_x))
    
    # Ensure that negative values do not occur
    interpolated[interpolated < 0] <- 0
    
    # Create a data frame with the interpolated values
    data.frame(
      ageyr = new_x,
      val_interpolated = interpolated
    )
  })
}


# Smooth spline

disagg_smooth_spline <- function(dat, key) {
  epsilon <- 1e-6
  
  with(dat, {
    x <- seq(from = floor(min(from_age)/5) * 5, to = 99, by = 5) 
    y <- log(rate_1 + epsilon)
    
    # browser()
    
    # Fit a smooth spline model
    fit <- smooth.spline(x, y)
    
    # browser()
    
    # Generate new x points
    new_x <- seq(min(x), min(99, max(x)), length.out = min(100, max(x) - min(x) + 1))
    
    # browser()
    
    # Predict values
    log_interpolated <- predict(fit, new_x)$y
    
      # browser()
    
    # Transform back from log scale
    interpolated <- exp(log_interpolated)
    
    # Ensure that negative values do not occur
    interpolated[interpolated < 0] <- 0
    
    # Create a data frame with the interpolated values
    data.frame(
      ageyr = new_x,
      val_interpolated = interpolated
    )
  })
}


# Apply the disaggregation function

# Group data for dissaggregation

gbdp_grp <- gbdp %>%
  group_by(measure, sex, cause) %>%
  arrange(measure, sex, cause, from_age)

# Apply function (select on of the above). Smooth_spline does a good job.
gbdpyr <- group_modify(gbdp_grp, disagg_smooth_spline) %>%
  ungroup()

#Join with original data where rates are the same within groups to validate interpolated data
gbdpyr <- gbdpyr %>%
  left_join(gbdpyrd5, by = c("measure", "ageyr", "sex", "cause"))

# Plot data to check interpolated values against 5-year age group values (original data)
## Four interpolation function could be use, the best fit should be used. For now, best fit to the data assessed visually.

# Melt the data to long format for ggplot
plot_data <- gbdpyr %>%
  select(measure, cause, sex, ageyr, rate_1, val_interpolated) %>%
  pivot_longer(cols = c(rate_1, val_interpolated), names_to = "type", values_to = "value")

# Define how many plots per page
nrow <- 3
ncol <- 2

# Create a combined cause and sex variable for faceting
plot_data <- plot_data %>%
  mutate(cause_sex = interaction(cause, sex))

# Define the number of unique facets
n_facets <- length(unique(plot_data$cause_sex))

# Calculate the number of pages needed
n_pages <- ceiling(n_facets / (nrow * ncol))

# Function to generate a plot for a specific page
plot_page <- function(page) {
  # Calculate the start and end index for the current page
  start <- (page - 1) * nrow * ncol + 1
  end <- min(page * nrow * ncol, n_facets)
  
  # Subset the data for the current page
  plot_data_subset <- plot_data %>%
    filter(cause_sex %in% unique(plot_data$cause_sex)[start:end])
  
  # Create the plot for the current page
  ggplot(plot_data_subset, aes(x = ageyr, y = value, color = type, linetype = type)) +
    geom_line() +
    facet_wrap(~ cause_sex, nrow = nrow, ncol = ncol, labeller = label_wrap_gen(width = 30)) +
    labs(title = "Original and Interpolated Rates",
         x = "Age",
         y = "Rate",
         color = "Rate Type",
         linetype = "Rate Type") +
    theme_minimal() +
    theme(
      legend.title = element_blank(),
      panel.background = element_rect(fill = "white"),
      plot.background = element_rect(fill = "white"),
      panel.grid.major = element_line(color = "gray80"),
      panel.grid.minor = element_line(color = "gray90")
    )
}

# Generate and save all pages
output_dir <- "docs/images/gbd_age_sex/"
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}


for (page in 1:n_pages) {
  p <- plot_page(page)
  file_path <- file.path(output_dir, paste0("plot_page_", page, ".png"))
  ggsave(filename = file_path, plot = p, width = 12, height = 8, bg = "white")
}

```

### Australian Institute of Health and Wellfare data for Australia: data interpolation

For cancers, we use data from AIHW, which similar to GBD, will be interpolated.

#### Harmonise definitions of cancer sites

The cancer sites are reported differently between the AIHW tables on incidence by age/sex and incidence by socioeconomic quintiles.

This table details the assumptions that are made in order to match the corresponding rates between the tables. The sites that we intend to use are defined by stdname and ICD10. Each row of the table below details the site from the AIHW tables that these are assumed to be matched to.

Note, sites are the same as causes in GBD.

```{r}

sites <- rbind( 
    ## Standard name,   Name in age/sex data,  Name in socio data,   Our intended ICD10,
    c("Breast cancer",   "Breast cancer"  ,      "Breast cancer in females (C50)" , "C50"),
     c("Endometrial cancer", "Endometrial cancer", "Uterine cancer (C54–C55)" ,  "C54–C55"),
      c("Lung cancer",       "Lung cancer",         "Lung cancer (C33–C34)",  "C33–C34"),
      c("Colon cancer",     "Colon cancer",         "Colorectal cancer (C18–C20)", "C18"),
      c("Esophageal cancer", "Oesophageal cancer" , NA,  "C15"),  
      c("Liver cancer",      "Liver cancer",       "Liver cancer (C22)", "C22"),
      c("Kidney cancer",     "Kidney cancer",    "Kidney cancer (C64)", "C64"),
      c("Gastric cardia cancer",  "Stomach cancer", NA, "C16"),
      c("Myeloid leukemia", "Chronic myeloid leukaemia (CML)"  , NA, "C92.1"),
      c("Myeloma", "Multiple myeloma", NA, "C90.0"),
      c("Head and neck cancer", "Head and neck cancer (including lip)", "Head and neck cancers (with lip) (C00–C14, C30–C32)", "C01–C14, C30–C32"),
      c("Rectum cancer", "Rectal cancer (including rectosigmoid junction)", "Colorectal cancer (C18–C20)", "C20"),
      c("Bladder cancer", "Bladder cancer", "Bladder cancer (C67)", "C67"),
      c("Prostate cancer", "Prostate cancer", "Prostate cancer (C61)", "C61"),
      c("Malignant melanoma", "Melanoma of the skin", "Melanoma of the skin (C43)", "C43"),
    c("All cancers", "All cancers combined", "All cancers combined (C00–C97, D45, D46, D47.1, D47.3–D47.5)", "C00–C97, D45, D46, D47.1, D47.3–D47.5")
    ) |> 
    as_tibble() |>
    setNames(c("stdname","agesexname","socioname","ICD10") ) |>
    select(stdname, ICD10, agesexname, socioname)

## This table is causing error, to be fixed (2/08/2024)
knitr::kable(sites, col.names = c("Standardised name","ICD 10 code",
             "Closest site in age/sex data","Closest site in socioeconomic data"))

# assume unique row in age-sex data for each standard site
stopifnot(!any(duplicated(sites$agesexname))) 
```

### Interpolate incidence by age and sex

```{r pressure, echo=FALSE}

library(readxl)

inc <- read_xlsx("health/original/AIHW/cancer-incidence.xlsx", sheet="Table S1a.1", skip=5, col_names=TRUE) %>% 
    filter(Year==2016) %>% # here 2016 to match inequality data.
    select(sex = Sex, age = "Age group (years)",
           site = "Cancer group/site",
           rate = "Age-specific rate\r\n(per 100,000)") %>%
    filter(age != "All ages combined",
           sex != "Persons") %>%
    mutate(age = ifelse(age=="90+","90–94",age), 
           rate_1=rate/100000) %>%
    separate_wider_delim(age, "–", names = c("from_age","to_age")) %>%
      mutate(across(from_age:to_age, as.numeric),
             agediff = to_age - from_age + 1) 

# to match other data add an age group from 95 to 99

inc_95 <- inc %>%
  filter(from_age == 90) %>%
  mutate(from_age = case_when(
    from_age == 90 ~ 95,  # Change `from_age` from 90 to 95
    TRUE ~ from_age       # Keep other values unchanged
  ),
  to_age = case_when(
    to_age == 94 ~ 99,    # Change `to_age` from 95 to 99
    TRUE ~ to_age         # Keep other values unchanged
  ))

inc <- inc %>% bind_rows(inc_95) %>%
  mutate(site = sites$stdname[match(site, sites$agesexname)]) %>%
  # Filter rows with valid site names
  filter(site %in% sites$stdname)

# Data expanded to one year age groups with 5-year value by sex and site repeated for each one year age group within age group. 

# Create index for repeating rows

index <- rep(1:nrow(inc), inc$agediff)

# Create the modified dataframe with repeated rows
incyrd5 <- inc[index, ]

# Additional processing if required, e.g., adding the ageyr column
# Assuming from_age, agediff, and other required columns are correctly defined
incyrd5 <- inc %>%
 mutate(across(from_age:to_age, as.numeric),
             agediff = to_age - from_age + 1) |>
    group_by(sex, site) |>
    slice(rep(1:n(), agediff)) %>%
    mutate(ageyr = row_number() - 1)

# Ensure that age is within the specified range (if necessary, based on incyrd5)
stopifnot(inc$ageyr >= inc$from_age, inc$ageyr <= inc$to_age)


# Group data for dissaggregation

inc_grp <- inc %>%
  group_by(site, sex) %>%
  arrange(site, sex, from_age)


# Apply function (select on of the above). Smooth_spline does a good job.
incyr <- group_modify(inc_grp, disagg_smooth_spline) %>%
  ungroup()

# Add age group 95 to 99, interpolation does not apply as same values for starting and end range

# Step 1: Filter rows where ageyr == 95
incyr_95 <- incyr %>%
  filter(ageyr == 95)

# Step 2: Repeat the filtered rows and change ageyr to 96, 96, 98, and 99
incyr_repeated <- incyr_95 %>%
  slice(rep(1:n(), each = 4)) %>%
  mutate(ageyr = case_when(
    row_number() %% 4 == 1 ~ 96,
    row_number() %% 4 == 2 ~ 96,
    row_number() %% 4 == 3 ~ 98,
    row_number() %% 4 == 0 ~ 99
  ))

# #Join with original data where rates are the same within groups to validate interpolated data
incyr <-incyr %>% 
  bind_rows(incyr_repeated) %>%
  left_join(incyrd5, by = c("ageyr", "sex", "site")) %>%
  mutate(site=tolower(site))

# Plot data to check interpolated values against 5-year age group values (original data)

# Melt the data to long format for ggplot
plot_data <- incyr %>%
  pivot_longer(cols = c(rate_1, val_interpolated), names_to = "type", values_to = "value")

# Define how many plots per page
nrow <- 3
ncol <- 2

# Create a combined site and sex variable for faceting
plot_data <- plot_data %>%
  mutate(site_sex = interaction(site, sex))

# Define the number of unique facets
n_facets <- length(unique(plot_data$site_sex))

# Calculate the number of pages needed
n_pages <- ceiling(n_facets / (nrow * ncol))

# Function to generate a plot for a specific page
plot_page <- function(page) {
  # Calculate the start and end index for the current page
  start <- (page - 1) * nrow * ncol + 1
  end <- min(page * nrow * ncol, n_facets)
  
  # Subset the data for the current page
  plot_data_subset <- plot_data %>%
    filter(site_sex %in% unique(plot_data$site_sex)[start:end])
  
  # Create the plot for the current page
  ggplot(plot_data_subset, aes(x = ageyr, y = value, color = type, linetype = type)) +
    geom_line() +
    facet_wrap(~ site_sex, nrow = nrow, ncol = ncol, labeller = label_wrap_gen(width = 30)) +
    labs(title = "Original and Interpolated Rates",
         x = "Age",
         y = "Rate",
         color = "Rate Type",
         linetype = "Rate Type") +
    theme_minimal() +
    theme(
      legend.title = element_blank(),
      panel.background = element_rect(fill = "white"),
      plot.background = element_rect(fill = "white"),
      panel.grid.major = element_line(color = "gray80"),
      panel.grid.minor = element_line(color = "gray90")
    )
}

# Generate and save all pages
output_dir <- "docs/images/aihw_age_sex/"
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}


for (page in 1:n_pages) {
  p <- plot_page(page)
  file_path <- file.path(output_dir, paste0("plot_page_", page, ".png"))
  ggsave(filename = file_path, plot = p, width = 12, height = 8, bg = "white")
}

```

### Inqualities in health

Above data is by age and sex, but we are interested in further dissertation to represent inequalities in health. Prepareation of inequalities data responds to inequality availability data for the following groups of diseases or single diseases: cancer, cardiovascular diseases and diabetes, COPD. For depression we did not find any data representing inequalities. Data sources are outlined here (Steve maybe there is a better way to share a file): https://rmiteduau.sharepoint.com/:x:/r/sites/JIBEworkinggroup/Shared%20Documents/General/health/diseases%20data.xlsx?d=w39d6dfa0db7c4a3294a89cf8ad3f71ee&csf=1&web=1&e=do8erQ

#### Cancers

We have data from the Cancer Atlas, by SA2 area and for males, females and persons. This is modelled data and methods are explained here (https://atlas.cancer.org.au/developing-a-cancer-atlas/) and here (https://pubmed.ncbi.nlm.nih.gov/31570101/). Data is available for the below cancer types and by SA2 area defined by the Australian Statistical Geography Standard July 2011 edition, with data on Capital Cities for Australia so we can select Melbourne. I joined all diseases data for incidence, for males and females, by SA2 area. Data is for standardised incidence ratio (SIR). The SIR reflects the area-specific incidence rate relative to the Australian average. It is the ratio of the observed cancer cases to the expected number of cases, the latter adjusting for difference in population between SA2 and differences in age structure of the population with an SA2.

```{r}

# Get sheet with SA2 areas by SES and filter Victoria

library(readxl)

excel_file <- "health/original/ATLAS/Atlas_estimates_95CIs.xlsx"

# Get the names of the sheets in the Excel workbook
diseases <- excel_sheets(excel_file)[-c(1:4)]

## Males
all_data_males <- list()

# Loop through each disease
for (sheet_name in diseases) {
  # Read data for the current disease
  data <- read_xlsx(excel_file, 
    sheet = sheet_name, 
    skip = 9, 
    col_names = TRUE, 
    n_max = 2200
  ) 
  
  # Process data for males
  males <- data %>%
    select(1:5) %>%
    setNames(.[2, ]) %>%
    slice(-1, -2) %>%
    mutate(sex = "Males",
           site = sheet_name)
  
  # Store the processed data in the list
  all_data_males[[sheet_name]] <- males
}

# Bind all data frames together
final_data_males <- do.call(rbind, all_data_males)



## females
all_data_females <- list()

# Loop through each disease
for (sheet_name in diseases) {
  # Read data for the current disease
  data <- read_xlsx(excel_file, 
    sheet = sheet_name, 
    skip = 9, 
    col_names = TRUE, 
    n_max = 2200
  ) 
  
  # Process data for males
  females <- data %>%
    select(1,2,6,7,8) %>%
  setNames(.[2, ]) %>%
  slice(-1, -2) %>%
  mutate(sex="Females",
           site = sheet_name)
  
  # Store the processed data in the list
  all_data_females[[sheet_name]] <- females
}

# Bind all data frames together
final_data_females <- do.call(rbind, all_data_females) 

SA2_soc <- read_xlsx(excel_file, sheet="Geography", skip=11, col_names = TRUE, n_max=2200)

data_combined <- bind_rows(final_data_females, final_data_males) %>%
  mutate(`SA2 code`=as.numeric(`SA2 code`)) %>%
 left_join(SA2_soc) %>% rename(SA2 = `SA2 name`)
# %>% filter(State=="Victoria", Remoteness=="Major city", `Capital cities`=="Greater Melbourne")
```

**Combining data sources**

I combined incidence data by age and sex for Australia wide with data for SA2 area. Data for SA2 area (data_combined) from the Atlas gives us the SIR, which is interpreted as the relative rate of incidence for an area, by sex to the Australian average. The Australian average is from AIHW and already stretched to one year age groups in data incyr.

Select data for health model in JIBE. Rate by sex, age and area is simply created by multiplying Standardized Incidence Rate (SIR) by age and sex rate.

```{r}


#Select diseases from ATLAS combined data
data_combined <- data_combined %>% filter(!(site %in% c("Brain Cancer", "Cervical Cancer", "Myeloproliferative neoplasms", "Non-Hodgkin Lymphoma", "Ovarian Cancer", "Pancreatic Cancer", "Thyroid Cancer"))) %>% mutate(site=tolower(site)) 
# 

# Atlas does not have data for bladder cancer, use data for all cancers and for colon and rectum separately, then us combined (bowel cancer) for each. 

bladder_cancer <- data_combined %>% filter(site=="all cancers") %>%
  mutate(site = if_else(site == "all cancers", "bladder cancer", site))

rectum_cancer <- data_combined %>% filter(site=="bowel cancer") %>%
  mutate(site = if_else(site == "bowel cancer", "rectum cancer", site))
  
data_sa2_sex <- data_combined %>%
  mutate(site = if_else(site == "bowel cancer", "colon cancer", site)) %>%
           bind_rows(bladder_cancer, rectum_cancer) %>%
  mutate(site = if_else(site == "uterine cancer", "endometrial cancer", site),
         site = if_else(site == "oesophageal cancer", "esophageal cancer", site),
         site = if_else(site == "melanoma", "malignant melanoma", site),
         site = if_else(site == "stomach cancer", "gastric cardia cancer", site), 
         site = if_else(site == "leukaemia", "myeloid leukemia", site),
         site = ifelse(site == "head and neck cancers", "head and neck cancer", site)) 


## Combine with incidence data by age and sex


data_sa2_sex_age <- data_sa2_sex %>% left_join(incyr, by=c("sex", "site")) %>%
  mutate(rate_area=as.numeric(SIR)*val_interpolated) %>%
  rename(socio=`Socioeconomic status`) 

# Save in final folder

cancer_incidence_area <- data_sa2_sex_age %>% rename (sa2_code=`SA2 code`, 
                                                      sa2_name = SA2) %>%
  mutate(prob=1 - exp(-rate_area)) %>%
  select(sa2_code, sa2_name, socio, site, age, sex, prob, rate_area, val_interpolated) %>%
  mutate(rate_ave_age_sex=val_interpolated*100000)

saveRDS(cancer_incidence_area, file="health/processed/cancer_incidence_area.rds")

## Compare data per SA2 and sex and data from national administrative sources by age, sex and combined with level of deprivation (Chris, see cancer incidence.Rmd)



compare_socio <- cancer_incidence_area %>%
group_by(age, sex, site, socio, rate_ave_age_sex, .groups = "drop") %>%
summarise(rate_area = round(mean(rate_area, na.rm = TRUE), 7), .groups = "drop") %>% mutate(socio=as.factor(socio)) %>%
  filter(socio != "Not classified") %>%
  mutate(sex = case_when(
    sex == "Females" ~ "Female",
    sex == "Males" ~ "Male"
  )) %>%
  mutate(rate_area=rate_area*100000)

cancerinc <- readRDS("health/processed/cancer_incidence.rds")

cancerinc <- cancerinc %>%
  mutate(socio = case_when(
    socio == "1 (most deprived)" ~ "Most disadvantaged",
    socio == "2" ~ "Disadvantaged",
    socio == "3" ~ "Middle SES", 
    socio == "4" ~ "Advantaged",
    socio == "5 (least deprived)" ~ "Most advantaged",
    TRUE ~ socio  # Handle default case
  )) %>%
mutate(socio=as.factor(socio)) %>%
  ungroup() %>%
  mutate(site=tolower(site))

compare_socio <- compare_socio %>% left_join(cancerinc, by=c("site", "age", "sex", "socio")) %>%
  mutate(rate_soc=round(rate, 2)) %>% select(!rate) 

compare_socio <- na.omit(compare_socio)

# is.na(compare_socio) #  this is to check for na values, there might be some if males for instance are assigned breast cancer or females prostate cancer. 

```

### THESE GRAPHS CODE NEEDS CHECKING, THE IDEA IS TO COMPARE RATES CALCULATED WITH ATLAS DATA, WITH AIHW DATA (CHRIS) AND AVERAGE BY AGE AND SEX FROM AIHW INTERPOLATED.

### STEVE CAN YOU PLEASE HELP WITH CHECKING THE DATA. rate_area is grouped by socio economic status to compare with rate_soc from data generated by Chris. Then I added the rate_ave_age_sex which is the aihw age and sex data. The idea is to check that the data makes sense, for example, we would expect the lowest socio economic rate for both rate_area and rate_soc to be higher than the rate_ave_age_sex. Note that the rate_soc data was not interpolated, hence the steps (this can be done if you wish to, code is available)

Each graph created below for each site and sex combinations depicts five graphs within representing each socioeconomic group, and within each graph by socioeconomic group a line called rate which represents the rate by age and sex for Australia wide (incyr), the rate derived from age and sex and age standardised rates by socioeconomic group called rate_soc (derived by Chris) and rate derived from data by sex and SA2 and rates by age and sex (rate_area).

```{r}

library(ggplot2)
rates_compare_long <- compare_socio %>% 
  pivot_longer(
  cols = c(rate_area, rate_soc, rate_ave_age_sex),
  values_to = "rate",
  names_to = "rate_type"
)



# Create folder if it doesn't exist
folder_path <- file.path("docs", "images", "inc_compare")
if (!file.exists(folder_path)) {
  dir.create(folder_path, recursive = TRUE)
}

# Define colors for rate types
rate_type_colors <- c("black", "red", "blue")

# Loop over each combination of site and sex
for (site_val in unique(rates_compare_long$site)) {
  for (sex_val in unique(rates_compare_long$sex)) {
    # Skip certain combinations of sex and site
    if ((sex_val == "Male" && site_val %in% c("breast cancer", "endometrial cancer")) ||
        (sex_val == "Female" && site_val == "prostate cancer")) {
      cat("Skipping graph for sex:", sex_val, "and site:", site_val, "\n")
      next  # Skip to the next iteration of the loop
    }
    
    cat("Processing site:", site_val, "and sex:", sex_val, "\n")  # Debug print statement
    
    # Subset data for the current combination of site and sex
    plot_data <- subset(rates_compare_long, site == site_val & sex == sex_val)
    
    # Check if there are data for the current combination
    if (nrow(plot_data) > 0) {
      max_rate <- max(plot_data$rate, na.rm = TRUE)
      cat("Maximum rate:", max_rate, "\n")  # Debug print statement
      
      # Create ggplot for the current combination
      p <- ggplot(plot_data, aes(x = age, y = rate, col = rate_type)) +
        geom_line(lwd = 1, aes(linetype = NULL)) +
        scale_color_manual(values = rate_type_colors) +
        facet_wrap(~socio, scales = "free_y", ncol = 1) + # Nested facet wrap for socio-economic status
        ylab("Incidence rate (per 100,000)") +
        xlab("Age (years)") +
        coord_cartesian(xlim = c(25, 90)) +
        scale_y_continuous(breaks = seq(0, max_rate, by = 400)) +  # Adjust y-axis breaks
        guides(alpha = FALSE, col = guide_legend(title = "Rate Type")) +
        theme(legend.position = "bottom", legend.box = "horizontal", legend.box.just = "center",
              legend.margin = margin(t = 5, unit = "pt"), legend.spacing = unit(0.2, "cm"))
      
      # Save the ggplot for the current combination
      png_name <- file.path(folder_path, paste0(site_val, "_", sex_val, ".png"))
      ggsave(png_name, plot = p + labs(title = paste("| Site:", site_val, "| Sex:", sex_val)), device = "png")
    } else {
      cat("No data for site:", site_val, "and sex:", sex_val, "\n")  # Debug print statement
    }
  }
}


# Second comparison difference between rate_soc and rate area

compare_diff <- compare_socio %>% 
  mutate(diff_rate = ifelse(rate_area == 0 | rate_soc == 0, 0, ((rate_area - rate_soc) / rate_soc) * 100)) 

```

#### Notes on comparison data sources

In general, rates calculated by Chris with AIHW data and rates derived from ATLAS data are very similar, with small discrepancies for cancer with small incidence rates.

Esophageal cancer rates for males are higher and lower respectively for disadvantaged and most disadvantage and most advantaged when usisng rates based on areas (ATLAS) data. Rates from socioeconomic status (from AIHW data) for esophageal cancer were assumed to follow the same patterns as all cancers.

For gastric cardia, for both males and females, rates based on areas (ATLAS) are slightly lower than from socio-economic data (AIHW) for males and females disadvantaged, most advantaged and advantaged groups.

For head and neck, rates for males and females from area rates (ATLAS) are more conservative than with AIHW, for example, for the advantaged group, area rates are higher than rates from socioeconomic data (AIHW). Similar pattern with liver cancer and lung cancer.

## Cardiovascular diseases and type 2 diabetes (STEVE, can you please paste the code below from cardiovascular_incidence.RDM. Please replace ensure that the incidence by age and sex is from the interpolated file (incyr (feel free to change to a better name accross the file). 

This script produces estimates of incidence for stroke, ischemic heart disease and type 2 diabetes by age, sex and area socioeconomic quintile, for Australia using data for 2016 and 2018.

The data is obtained from the Global Burden of Disease for disease incidence by age and sex and from AIHW by sex and socioeconomic status (JIBE data summary spreadsheet). There is no unique source of data for what we need, hence the combination of data sources. Source files:

Incidence by 5-year age group and sex for stroke, ischemic heart disease and type 2 diabetes:

-   gbd_incidence.csv (available from GBD data tool, data is for 2018, baseline year for the jibe model)

Incidence, death and prevalence by sex and socioeconomic area for 2016. We do not have data for incidence by socioeconomic area for all diseases of interest, hence, we use deaths and prevalence, depending which one is more suitable.

-   cvd_dia_kid_socioeconomic.xlsx, which contains:

    -   Stroke incidence: by sex and socioeconomic area for 2016: Table S2

    -   Cardiovascular disease death: by sex and socioeconomic area for 2016: Table S2

    -   Type 2 diabetes prevalence: by sex and socioeconomic area for 2016: Table S7

These data refer to the whole of Australia, and we do not have area specific data (e.g. SA2 as we do with mortality and incidence). These data are combined to produce estimates for each of stroke, ischemic heart disease and type 2 diabetes by age, sex and area socioeconomic quintile. This assumes that the effect of socioeconomic status on stroke, ischemic heart disease and diabetes type 2 incidence is the same for all age and sex groups.

# STEVE, can you please add COPD, same as above, please use interpolated data. Also, note that I created folder for images (docs/images/...) with names that aim to identify the gaphs within (again, if not obvious to you, please change). 

# STEVE, CAN YOU PLEASE ADD THE MORTALITY FILE HERE AS WELL? SINCE THE METHODS FOR DERIVING RATES PER SOCIO ARE REPETITIVE, PLEASE FEEL FREE TO ADD ONLY ONCE, PERHAPS AT TOP AND THEN REFER TO THEM. 

# 
